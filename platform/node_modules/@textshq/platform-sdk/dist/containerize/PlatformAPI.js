"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const worker_threads_1 = require("worker_threads");
// this is like PlatformAPIRelayer
class ContainerizedPlatformAPI {
    containerConstructor;
    container;
    requestQueue = new Map();
    // key: methodName, value: callback
    callbacks = new Map();
    requestId = 0;
    callMethod(methodName, args, isCallback = false) {
        return new Promise((resolve, reject) => {
            const reqID = ++this.requestId;
            this.requestQueue.set(reqID, { resolve, reject });
            this.container.postMessage({
                type: 2 /* MessageType.CallMethod */,
                reqID,
                methodName,
                args,
                isCallback,
            });
        });
    }
    handleWorkerCleanupMessage = (value) => {
        if (value === 'cleanup') {
            this.dispose();
        }
    };
    async initContainer(dataDirPath) {
        await fs_1.promises.mkdir(dataDirPath, { recursive: true });
        worker_threads_1.parentPort?.on('message', this.handleWorkerCleanupMessage);
        this.container = this.containerConstructor(dataDirPath);
        await this.container.initPromise;
        this.container.onMessage((msg) => {
            switch (msg.type) {
                case 0 /* MessageType.MethodResult */: {
                    const { reqID, result, error } = msg;
                    if (this.requestQueue.has(reqID)) {
                        const promise = this.requestQueue.get(reqID);
                        if (promise) {
                            if (error) {
                                promise.reject(new Error(error.name + ' ' + error.message));
                            }
                            else { // result can be undefined
                                promise.resolve(result);
                            }
                        }
                        this.requestQueue.delete(reqID);
                    }
                    else {
                        throw Error('unknown method-result message');
                    }
                    return;
                }
                case 1 /* MessageType.Callback */: {
                    const { methodName, args } = msg;
                    this.callbacks.get(methodName)?.(...args);
                    break;
                }
                default:
                    console.log(msg);
                    throw Error('unknown ContainerToMainMessage');
            }
        });
    }
    constructor(containerConstructor) {
        this.containerConstructor = containerConstructor;
        // eslint-disable-next-line no-constructor-return
        return new Proxy(this, {
            get(target, prop) {
                if (prop in target)
                    return target[prop];
                return (...args) => {
                    if (typeof args[0] === 'function') {
                        target.callbacks.set(prop, args[0]);
                        return target.callMethod(prop, [], true);
                    }
                    return target.callMethod(prop, args);
                };
            },
            has: () => true,
        });
    }
    init = async (session, clientContext) => {
        await this.initContainer(clientContext.dataDirPath);
        return this.callMethod('init', [session, clientContext]);
    };
    dispose = async () => {
        await this.callMethod('dispose', []);
        this.container?.dispose();
        worker_threads_1.parentPort?.off('message', this.handleWorkerCleanupMessage);
    };
}
exports.default = ContainerizedPlatformAPI;
