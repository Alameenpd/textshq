"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const __1 = require("..");
class ChildProcessContainer {
    entryPointJSPath;
    env;
    cp;
    initPromise;
    lockFilePath;
    constructor(entryPointJSPath, env, dataDirPath) {
        this.entryPointJSPath = entryPointJSPath;
        this.env = env;
        this.lockFilePath = path_1.default.join(dataDirPath, 'cli-lock-pid');
        this.initPromise = this.init();
    }
    async ensureSingleton() {
        try {
            const pid = await fs_1.promises.readFile(this.lockFilePath, 'utf-8');
            if (pid) {
                console.log('[cp container] killing existing cp with pid', pid);
                process.kill(+pid);
            }
        }
        catch (err) {
            __1.texts.error(err);
            __1.texts.Sentry.captureException(err);
        }
    }
    async init() {
        await this.ensureSingleton();
        __1.texts.log('[cp container] init', this.entryPointJSPath);
        this.cp = __1.texts.forkChildProcess(this.entryPointJSPath, {
            env: {
                ...process.env,
                ...this.env,
            },
        }, { noSentry: true });
        const fsPromise = fs_1.promises.writeFile(this.lockFilePath, String(this.cp.pid));
        await Promise.all([
            fsPromise,
            new Promise((resolve, reject) => {
                this.cp
                    .once('spawn', () => resolve())
                    .on('close', code => __1.texts.log(`child process close all stdio with code ${code}`))
                    .on('exit', code => __1.texts.log(`child process exited with code ${code}`))
                    .once('error', err => {
                    __1.texts.log(`child process errored ${err}`);
                    reject(err);
                })
                    .on('error', err => {
                    __1.texts.log(`child process errored ${err}`);
                    __1.texts.Sentry.captureException(err);
                });
            }),
        ]);
    }
    onMessage(handler) {
        this.cp.on('message', handler);
    }
    postMessage(msg) {
        this.cp.send(msg);
    }
    async dispose() {
        this.cp.kill();
        await fs_1.promises.unlink(this.lockFilePath).catch(() => { });
    }
}
exports.default = ChildProcessContainer;
