"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpectedJSONGotHTMLError = exports.htmlTitleRegex = exports.tryParseJSON = exports.smartJSONStringify = exports.getDataURI = void 0;
const getDataURI = (buffer, mimeType = '') => `data:${mimeType};base64,${buffer.toString('base64')}`;
exports.getDataURI = getDataURI;
const isArray = (x) => Array.isArray(x);
const isString = (x) => typeof x === 'string';
const isObject = (x) => typeof x === 'object' && x !== null;
const isBufferLike = (x) => isObject(x) && x.type === 'Buffer' && (isArray(x.data) || isString(x.data));
/* handles `Buffer`s and `BigInt`s better */
const smartJSONStringify = (obj, space) => JSON.stringify(obj, (key, value) => {
    if (typeof value === 'bigint')
        return value.toString();
    if (isBufferLike(value))
        return (0, exports.getDataURI)(Buffer.from(value.data));
    return value;
}, space);
exports.smartJSONStringify = smartJSONStringify;
function tryParseJSON(json, fallback) {
    try {
        return JSON.parse(json);
    }
    catch {
        return fallback;
    }
}
exports.tryParseJSON = tryParseJSON;
exports.htmlTitleRegex = /<title[^>]*>(.*?)<\/title>/;
class ExpectedJSONGotHTMLError extends Error {
    constructor(statusCode, html) {
        const [, title] = exports.htmlTitleRegex.exec(html) || [];
        super(`expected json, got html, status code=${statusCode}, title=${title}`);
    }
}
exports.ExpectedJSONGotHTMLError = ExpectedJSONGotHTMLError;
