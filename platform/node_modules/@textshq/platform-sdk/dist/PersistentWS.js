"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("timers/promises");
const ws_1 = __importDefault(require("ws"));
const lodash_1 = require("lodash");
const _1 = require(".");
const MAX_RETRY_ATTEMPTS = Infinity;
const getRetryTimeout = (attempt) => // 60s after 16 attempts
 Math.min(Math.floor(100 + (2 ** attempt + (Math.random() * 100))), 60000);
const WAIT_DELAY_MS = 50;
// similar to texts-app-desktop/src/renderer/ws-transport.ts
class PersistentWS {
    getConnectionInfo;
    onMessage;
    onOpen;
    onClose;
    onError;
    ws;
    disposing = false;
    retryAttempt = 0;
    connectTimeout;
    lastOpen;
    constructor(getConnectionInfo, onMessage, onOpen, onClose, onError) {
        this.getConnectionInfo = getConnectionInfo;
        this.onMessage = onMessage;
        this.onOpen = onOpen;
        this.onClose = onClose;
        this.onError = onError;
    }
    connect = async () => {
        try {
            this.dispose();
        }
        catch (err) {
            _1.texts.error('[PersistentWS] connect dispose error', err);
        }
        // 'error' and 'close' can be dispatched in tandem under certain
        // circumstances[1]; guard our retry logic behind a debounce to prevent
        // introducing two conflicting reconnection "threads".
        //
        // [1]: https://github.com/websockets/ws/blob/5e42cfdc5fa114659908eaad4d9ead7d5051d740/lib/websocket.js#L1031
        const retry = (0, lodash_1.debounce)(() => {
            if (++this.retryAttempt <= MAX_RETRY_ATTEMPTS) {
                const retryAfter = getRetryTimeout(this.retryAttempt);
                _1.texts.log('[PersistentWS] will retry after', retryAfter, 'ms');
                clearTimeout(this.connectTimeout);
                this.connectTimeout = setTimeout(() => {
                    // Check if someone reconnected us while we were
                    // asleep.
                    //
                    // For example, Texts invokes platforms' `reconnectRealtime` methods
                    // once it notices that network connectivity has returned. Depending
                    // on platform logic, our `connect` method could be called before
                    // we enter this function.
                    if (this.connected) {
                        _1.texts.log('[PersistentWS] skipping post-scheduled connect(), already connected');
                        return;
                    }
                    this.connect();
                }, retryAfter);
            }
            else {
                this.disposing = true;
            }
        }, 25);
        const { endpoint, options } = await this.getConnectionInfo();
        _1.texts.log(`[PersistentWS] ${this.lastOpen ? 're' : ''}connecting`, endpoint);
        this.ws = new ws_1.default(endpoint, options);
        this.ws
            .on('open', () => {
            _1.texts.log('[PersistentWS] open', this.lastOpen ? `${(this.lastOpen.getTime() - Date.now()) / 1000}s` : '');
            this.lastOpen = new Date();
            this.disposing = false;
            this.retryAttempt = 0;
            this.onOpen?.();
        })
            .on('message', this.onMessage)
            .on('close', code => {
            _1.texts.log('[PersistentWS] close', { code });
            if (this.disposing)
                this.disposing = false;
            else if (this.onClose?.(code)?.retry ?? true) {
                retry();
            }
        })
            .on('error', error => {
            console.error('[PersistentWS] error', error);
            const shouldRetry = this.onError?.(error)?.retry ?? true;
            if (this.disposing)
                this.disposing = false;
            else if (shouldRetry)
                retry();
        });
    };
    /**
     * Note: this isn't always accurate, the internet could be down/turned off and this may still return true
     * */
    get connected() {
        return this.ws && this.ws?.readyState === this.ws?.OPEN;
    }
    waitAndSend = async (data) => {
        while (!this.connected) {
            if (this.disposing)
                return; // we're dropping this data since we're disposing
            _1.texts.log(`[PersistentWS] waiting ${WAIT_DELAY_MS}ms`);
            await (0, promises_1.setTimeout)(WAIT_DELAY_MS);
        }
        this.send(data);
    };
    send = (data) => {
        if (!this.connected)
            return this.waitAndSend(data);
        this.ws.send(data);
    };
    /**
      * Initiate a closing handshake. Upon completion, {@linkcode onClose} is
      * called and its return value is consulted to determine reconnection
      * behavior (defaulting to a reconnect).
      *
      * **IMPORTANT**: If sending the server a close frame takes too long for
      * whatever reason (such as if the network is down), a close will occur after
      * 30 seconds (the timeout for a close handshake) with a code of `1006`,
      * regardless of any code passed into this method.
      */
    disconnect(code) {
        if (!this.ws)
            return;
        this.lastOpen = undefined;
        this.ws.close(code);
    }
    /**
      * Forcibly close the underlying WebSocket connection. This immediately
      * dispatches {@linkcode onClose} with a code of `1006`, and the return value
      * is consulted to determine reconnection behavior (defaulting to a reconnect).
      *
      * If the WebSocket is in the middle of connecting, {@linkcode onError} is
      * also called.
      */
    forceDisconnect() {
        if (!this.ws)
            return;
        this.lastOpen = undefined;
        this.ws.terminate();
    }
    /**
      * Initiate a closing handshake _without_ calling {@linkcode onClose} upon
      * completion. This prevents automatic reconnection from occurring. To
      * initiate another connection after using this method, call {@linkcode connect}.
      *
      * Please see the note described in the documentation for {@linkcode disconnect}.
      */
    dispose(code) {
        if (!this.ws)
            return;
        this.lastOpen = undefined;
        this.disposing = true;
        this.ws.close(code);
    }
}
exports.default = PersistentWS;
